#!/bin/bash
set -e

# Validate required environment variables
if [ -z "$CLAUDE_CODE_OAUTH_TOKEN" ]; then
    echo "Error: CLAUDE_CODE_OAUTH_TOKEN environment variable is required"
    exit 1
fi

if [ -z "$API_KEY" ]; then
    echo "Error: API_KEY environment variable is required"
    exit 1
fi

# Role defaults to worker, can be set to "lead"
ROLE="${AGENT_ROLE:-worker}"
MCP_URL="${MCP_BASE_URL:-http://host.docker.internal:3013}"

# Determine YOLO mode based on role
if [ "$ROLE" = "lead" ]; then
    YOLO_MODE="${LEAD_YOLO:-false}"
else
    YOLO_MODE="${WORKER_YOLO:-false}"
fi

echo "=== Agent Swarm ${ROLE^} ==="
echo "Agent ID: ${AGENT_ID:-<not set>}"
echo "MCP Base URL: $MCP_URL"
echo "YOLO Mode: $YOLO_MODE"
echo "Session ID: ${SESSION_ID:-<auto-generated>}"
echo "Working Directory: /workspace"
echo "=========================="

# Initialize PM2 daemon for background service management
echo ""
echo "=== PM2 Initialization ==="
echo "PM2 Home: ${PM2_HOME:-~/.pm2}"
# Ensure PM2 home directory exists (for persistence in /workspace)
mkdir -p "${PM2_HOME:-$HOME/.pm2}"
pm2 startup > /dev/null 2>&1 || true
# Restore previously saved processes (from pm2 save)
if pm2 resurrect 2>/dev/null; then
    echo "PM2 restored saved processes"
    pm2 list
else
    echo "PM2 daemon ready (no saved processes)"
fi
echo "=========================="

# Cleanup function for graceful shutdown
cleanup() {
    echo ""
    echo "Shutting down PM2 processes..."
    pm2 kill 2>/dev/null || true
}
trap cleanup EXIT SIGINT SIGTERM

# Create .mcp.json in /workspace (project-level config)
echo "Creating MCP config in /workspace..."
if [ -n "$AGENT_ID" ]; then
    cat > /workspace/.mcp.json << EOF
{
  "mcpServers": {
    "agent-swarm": {
      "type": "http",
      "url": "${MCP_URL}/mcp",
      "headers": {
        "Authorization": "Bearer ${API_KEY}",
        "X-Agent-ID": "${AGENT_ID}"
      }
    }
  }
}
EOF
else
    cat > /workspace/.mcp.json << EOF
{
  "mcpServers": {
    "agent-swarm": {
      "type": "http",
      "url": "${MCP_URL}/mcp",
      "headers": {
        "Authorization": "Bearer ${API_KEY}"
      }
    }
  }
}
EOF
fi

# Configure GitHub authentication if token is provided
echo ""
echo "=== GitHub Authentication ==="
if [ -n "$GITHUB_TOKEN" ]; then
    echo "Configuring GitHub authentication..."

    # gh CLI will automatically use GITHUB_TOKEN env var for API calls
    # Just need to configure git to use gh as credential helper
    gh auth setup-git

    # Set git user config for commits (use env vars or defaults)
    GIT_EMAIL="${GITHUB_EMAIL:-worker-agent@desplega.ai}"
    GIT_NAME="${GITHUB_NAME:-Worker Agent}"
    git config --global user.email "$GIT_EMAIL"
    git config --global user.name "$GIT_NAME"

    echo "GitHub authentication configured successfully"
    echo "Git user: $GIT_NAME <$GIT_EMAIL>"
else
    echo "WARNING: GITHUB_TOKEN not set - git push operations will fail"
fi
echo "=============================="

# Execute startup script if found
STARTUP_SCRIPT_STRICT="${STARTUP_SCRIPT_STRICT:-true}"
echo ""
echo "=== Startup Script Detection (${ROLE}) ==="

# Find startup script matching /workspace/start-up.* pattern
STARTUP_SCRIPT=""
for pattern in start-up.sh start-up.bash start-up.js start-up.ts start-up.bun start-up; do
    if [ -f "/workspace/${pattern}" ]; then
        STARTUP_SCRIPT="/workspace/${pattern}"
        break
    fi
done

if [ -n "$STARTUP_SCRIPT" ]; then
    echo "Found startup script: $STARTUP_SCRIPT"

    # Check if file is executable
    if [ ! -x "$STARTUP_SCRIPT" ]; then
        echo "Script is not executable, checking for shebang..."
    fi

    # Read first line to check for shebang
    FIRST_LINE=$(head -n 1 "$STARTUP_SCRIPT")

    if [[ "$FIRST_LINE" =~ ^#! ]]; then
        # Has shebang - extract interpreter
        INTERPRETER="${FIRST_LINE#\#!}"
        # Trim whitespace
        INTERPRETER=$(echo "$INTERPRETER" | xargs)
        echo "Detected shebang interpreter: $INTERPRETER"

        # Check if it's an env-based shebang (#!/usr/bin/env bash)
        if [[ "$INTERPRETER" =~ ^/usr/bin/env ]]; then
            ACTUAL_INTERPRETER=$(echo "$INTERPRETER" | awk '{print $2}')
            echo "Using env interpreter: $ACTUAL_INTERPRETER"
            INTERPRETER="$ACTUAL_INTERPRETER"
        fi

        echo "Executing startup script with interpreter: $INTERPRETER"
        # Always use the interpreter explicitly to avoid permission issues
        # Use || true to prevent set -e from exiting before we can handle the error
        $INTERPRETER "$STARTUP_SCRIPT" || EXIT_CODE=$?
        EXIT_CODE=${EXIT_CODE:-0}
    else
        # No shebang, try to infer from extension
        EXTENSION="${STARTUP_SCRIPT##*.}"
        echo "No shebang found, inferring from extension: .$EXTENSION"

        case "$EXTENSION" in
            sh|bash)
                echo "Executing with bash..."
                bash "$STARTUP_SCRIPT" || EXIT_CODE=$?
                ;;
            js)
                echo "Executing with node..."
                node "$STARTUP_SCRIPT" || EXIT_CODE=$?
                ;;
            ts)
                echo "Executing with bun (TypeScript)..."
                bun run "$STARTUP_SCRIPT" || EXIT_CODE=$?
                ;;
            bun)
                echo "Executing with bun..."
                bun run "$STARTUP_SCRIPT" || EXIT_CODE=$?
                ;;
            *)
                # Try to execute directly if executable
                if [ -x "$STARTUP_SCRIPT" ]; then
                    echo "Executing directly (executable bit set)..."
                    "$STARTUP_SCRIPT" || EXIT_CODE=$?
                else
                    echo "WARNING: Unknown extension and not executable, trying bash..."
                    bash "$STARTUP_SCRIPT" || EXIT_CODE=$?
                fi
                ;;
        esac
        EXIT_CODE=${EXIT_CODE:-0}
    fi

    # Handle exit code
    if [ $EXIT_CODE -ne 0 ]; then
        echo ""
        echo "ERROR: Startup script failed with exit code $EXIT_CODE"

        if [ "$STARTUP_SCRIPT_STRICT" = "true" ]; then
            echo "STARTUP_SCRIPT_STRICT=true - Exiting..."
            exit $EXIT_CODE
        else
            echo "STARTUP_SCRIPT_STRICT=false - Continuing despite error..."
        fi
    else
        echo "Startup script completed successfully"
    fi
else
    echo "No startup script found (looked for /workspace/start-up.*)"
    echo "Skipping startup script execution"
fi

echo "==============================="
echo ""

# Run the agent using compiled binary
echo "Starting $ROLE..."
exec /usr/local/bin/agent-swarm "$ROLE" "$@"
